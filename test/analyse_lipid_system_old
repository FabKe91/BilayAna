#!/usr/bin/env python3

''' 
    #######    Program to analyse a membrane System  ########

    This will create files in current folder.
    An inputfile with system information and raw-mdpfile is required.
    For testing, specify the last lipid molecule in g_number_of_lipids, if all lipids are to be calculated set g_number_of_lipids='all'.
    Specify gmx_exec to the name of gromacs binary.
    Specify g_denominator for energycalculation, to split the neighbors of host in different groups.

'''

##################################################

import os
import subprocess
import sys
from time import localtime, strftime
from datetime import datetime

###################################################

gmx_exec = 'gmx' #'gmx_5.0.4_mpi'
g_denominator=40 #62
g_number_of_lipids='all' #'all'

###################################################

def print_to_file(str, file):
    file.write(str + '\n')
#def print(str, end):
##    print(end+str)

###################################################


class AnalyseLipidSystem:
    def __init__(self, inputfile):
        print("\n\n _____Initialize analysis______ \n\n")
        self.system_info={} # Dict to extract infos from system info file
        '''    ################################## Inputinfofile'''
        with open(inputfile,"r") as inp:
            filecontent=[x.split(': ') for x in [y.strip('\n') for y in inp.readlines()]] #Creates a list like [[system,dppc_chol],[temperature,290]]
            for info in filecontent:
                if len(info)==2 and not '#' in info[0]:
                    self.system_info.update({info[0]:info[1]})
                    print("{} : {}".format(info[0],info[1]),"\n")
            sys.stdout.flush()
        '''   ##################################'''

        
        '''create all needed folders '''
        cwd=os.getcwd()
        try:
            os.mkdir('datafiles')
        except OSError as err:
            pass
        try:
            os.mkdir('indexfiles')
        except OSError as err:
            pass
        try:
            os.mkdir('tempfiles')
        except OSError as err:
            pass
        try:
            os.mkdir('energyfiles')
        except OSError as err:
            pass
            
            
        ''' outputpaths (specify _absolute_ paths! '''
        self.mdfilepath=self.system_info['mdfiles']
        self.indexpath="{}/indexfiles".format(cwd)
        self.datapath="{}/datafiles".format(cwd)
        self.temppath="{}/tempfiles".format(cwd)
        self.energypath="{}/energyfiles".format(cwd)

        
        ''' general system information '''
        self.system=self.system_info['System']
        self.temperature=self.system_info['Temperature']
        self.molecules=[x.upper() for x in self.system_info['Lipidmolecules'].split(',')]   #Lipid molecules in system
        if 'CHOL' in self.molecules:
            self.molecules.append('CHL1')
        self.times=[self.system_info['Timeframe'].split(',')[0],self.system_info['Timeframe'].split(',')[1],self.system_info['Timeframe'].split(',')[2]] #Start,End,step
        if self.times[1]=='end':
            print("Not yet implemented")
        else:
            self.t_end=int(self.times[1])
            self.t_start=int(self.times[0])
            self.dt=int(self.times[2])


        
        '''_absolute_ paths to  md-files  '''
        self.trjpath='{}/md_trj/{}_{}.trr'.format(self.mdfilepath,self.system,self.temperature)
        self.gropath='{}/initial_coords/{}.gro'.format(self.mdfilepath,self.system)
        self.toppath='{}/psf/{}.top'.format(self.mdfilepath,self.system)
        self.tprpath='{}/tpr/{}_{}'.format(self.mdfilepath,self.system,self.temperature)
        

        ''' atom selections  '''
        #self.tail_atoms_of={\
        #                'DPPC':[['C21','C22','C23','C24','C25', 'C26','C27', 'C28','C29', 'C210','C211', 'C212','C213', 'C214','C215', 'C216'],\
        #                    ['C31','C32','C33', 'C34','C35', 'C36','C37', 'C38','C39', 'C310','C311', 'C312','C313', 'C314','C315', 'C316']],\
        #                'CHL1':[[]],\
        #                'DUPC':[['C21','C22','C23','C24','C25', 'C26','C27', 'C28','C29', 'C210','C211', 'C212','C213', 'C214','C215', 'C216','C217','C218'],\
        #                      ['C31','C32','C33', 'C34','C35', 'C36','C37', 'C38','C39', 'C310','C311', 'C312','C313', 'C314','C315', 'C316','C317','C318']]}
                    
        self.scd_tail_atoms_of={\
                        'DPPC':[['C22','C24','C26', 'C28', 'C210', 'C212', 'C214', 'C216'],\
                            ['C32', 'C34', 'C36','C38', 'C310', 'C312', 'C314', 'C316']],\
                        'CHL1':[['C3','C17']],\
                        'DUPC':[['C21','C23','C25', 'C27','C29','C211', 'C213', 'C215','C217'],\
                            ['C31','C33','C35', 'C37','C39','C311', 'C313', 'C315','C317']]}
                    
        self.central_atom_of={\
                                'DPPC':'P',\
                                'CHOL':'O3',\
                                'DUPC':'P',\
                                'DOPC':'P'}

        #########################################################################################################
        
        self.index_to_resid,self.resid_to_lipid=self.index_conversion_dict()
        self.system_size,self.number_of_lipids=self.determine_systemsize_and_number_of_lipids()
        global g_number_of_lipids
        if g_number_of_lipids == 'all':
            g_number_of_lipids=self.number_of_lipids
        print('Total number of atoms: {}\nNumber of lipids: {}\n\n ___________________'.format(self.system_size,self.number_of_lipids))
        sys.stdout.flush()
        #########################################################################################################
        
    


    ############################################################################################################################
    ############################################################################################################################
    ############################################################################################################################

    ''' preparation tools '''

    def exec_gromacs(self,cmd,inp_str=None): 
        '''arglist (cmd) is list of arguments with form ['gmx cmd','-f','tprfile','-e','en.edr'], inp_str must be byte b' ' !'''
        if inp_str is None:
            proc = subprocess.Popen(cmd,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            out, err = proc.communicate()
        else:
            proc = subprocess.Popen(cmd,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            out, err = proc.communicate(inp_str)
        proc.wait()
        proc.stdout.close()
        proc.stderr.close()
        return out, err
    
    
    def index_conversion_dict(self): 
        ''' returns a dictionary for conversion from index to resid '''
        grofile=self.gropath
        in2res={}
        res2mol={}
        with open(grofile,"r") as fgro:
            fgro.readline(); fgro.readline() #get rid of first 2 lines
            for lines in fgro:
                resid=int(float(lines[:5].strip()))
                lipid=lines[5:9]
                atom=lines[10:15].strip()
                ind=int(float(lines[15:20].strip()))
                if lipid=='DPPC' or lipid=='DUPC' and atom=='P':
                    in2res.update({ind:resid})
                    res2mol.update({resid:lipid})
                elif lipid=='CHL1' and atom=='O3':
                    in2res.update({ind:resid})
                    res2mol.update({resid:lipid})
        return in2res,res2mol

    
    def determine_systemsize_and_number_of_lipids(self):
        ''' returns number of atoms in system and number of lipid molecules '''
        grofile=self.gropath
        number_of_lipids=0
        with open(grofile,"r") as fgro:
            resids=[]
            fgro.readline()                     #get rid of first line
            system_size=int(fgro.readline())    #second line is systemsize info
            lines=fgro.readlines()
            del lines[-1]
            for item in lines:
                lipid=item[5:9]
                resid=item[:5].strip()
                if lipid in self.molecules:
                    resids+=[resid]
            resids=list(set(resids))
            resids=[int(x) for x in resids]
            if max(resids) == len(resids):
                number_of_lipids=len(resids)
            else:
                print('Something went wrong: Not all lipids found.')
        sys.stdout.flush()
        return system_size,number_of_lipids


    def create_selectionfile_neighborsearch(self,resid):
        filename="{}/neighbors_of_residue{}".format(self.temppath,resid)
        with open(filename,"w") as selection:
            print_to_file("host =  resid {} and (name P O3);\n\
                allOAtoms = resname CHL1 and name O3 and not host;\n\
                allPAtoms = resname DPPC DUPC and name P and not host;\n\
                neibOs = allOAtoms and within 1.0 of host;\n\
                neibPs = allPAtoms and within 1.0 of host;\n\
                neibs = neibPs or neibOs;\n\
                neibs;".format(resid),file=selection)
        return filename


    def find_all_neighbors(self):
        ''' Returns a list of all neighbors being in the cutoff distance at least once in the trajectory. Neighborfile is output of "determine_neighbors()" '''
        neighborfile="neighbor_info"
        neib=[0,[]]
        neiblist=[[]]
        with open(neighborfile,"r") as neibmap:
            fileheader=neibmap.readline() 
            for line in neibmap:
                cols=line.split()
                if neib[0]==int(cols[0]) and int(cols[2])!=0:
                    neib[1]+=[int(x) for x in cols[3].split(",")]
                    resindex=int(cols[0])
                    neiblist[resindex][1]+=neib[1]
                    neiblist[resindex][1]=list(set(neiblist[resindex][1]))
                    if neiblist[resindex][0] in neiblist[resindex][1]:
                        print("Residue {} is its own neighbor.".format(cols[0]))
                        break
                elif int(cols[2])!=0:
                    neib=[0,[]]
                    neib[0]=int(cols[0])
                    neib[1]+=[int(x) for x in cols[3].split(",")]
                    neiblist+=[neib]
                elif int(cols[2])==0:
                    print("No neighbors of residue {} at time {}.".format(cols[0],cols[1]))
                else:
                    print("Something went wrong on line: \n '{}'".format(line))
        sys.stdout.flush()
        return neiblist

    def create_indexfile(self):
        print("\n_____Creating index file____\n")
        ''' Creates an indexfile containing all indeces of atom of each residue in system (resid_X) and all indeces of all atoms in system.   '''
        #OUTPUT IS:    resindex_all.ndx     | in the cwd!
        for i in range(1,self.number_of_lipids+1):
            print('Working on resiue {}'.format(i),end='\r')
            selectionfile=self.temppath+'/tmp_selectionfile'
            with open(selectionfile,"w") as sf:
                if self.resid_to_lipid[i] == 'DPPC':
                    selectionstring = "resid_"+str(i)+"=resid "+str(i)+" and resname DPPC;\nresid_"+str(i)+';'
                    sf.write(selectionstring)
                elif self.resid_to_lipid[i] == 'CHL1':
                    selectionstring="resid_"+str(i)+"=resid "+str(i)+" and resname CHL1;\nresid_"+str(i)+';'
                    sf.write(selectionstring)
                elif self.resid_to_lipid[i] == 'DUPC':
                    selectionstring="resid_"+str(i)+"=resid "+str(i)+" and resname DUPC;\nresid_"+str(i)+';'
                    sf.write(selectionstring)
            outputindex=self.indexpath+"/resid_"+str(i)+".ndx"
            gmx_select_arglist=[gmx_exec,'select','-s',self.gropath,'-sf',selectionfile,'-on',outputindex]
            out,err=self.exec_gromacs(gmx_select_arglist)
            with open("gmx_select.log","w") as logfile, open(outputindex,"r") as output_index, open("resindex_all.ndx","a") as resindex_all:
                logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
                filecontent=output_index.readlines()
                resindex_all.write(''.join(filecontent)+'\n\n')
        make_ndx_output=self.temppath+'/make_ndx_system.ndx'
        gmx_make_ndx_arglist=[gmx_exec,'make_ndx','-f',self.gropath,'-o',make_ndx_output]
        inp_str=b'keep 0\nq\n'
        out,err=self.exec_gromacs(gmx_make_ndx_arglist,inp_str)
        with open("gmx_make_ndx.log","w") as logfile, open(make_ndx_output,"r") as output, open("resindex_all.ndx","a") as resindex_all:
            logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
            filecontent=output.readlines()
            resindex_all.write(''.join(filecontent)+"\n\n")
   
   
   
    
    ############################################################################################################################
    ############################################################################################################################
    ############################################################################################################################
    ############################################################################################################################

    ''' ____________________________________________ main calculations tools __________________________________________'''
    
    
    
    def calculate_scds(self):
        print("\n_____Extracting Scd values____\n")
        if "CHOL" in self.molecules:
            molecules_new=self.molecules.copy()
            molecules_new.remove("CHOL")
            print(molecules_new)
        else:
            molecules_new=self.molecules
            
        getcoords={}
        resid2lipid={}
        list_of_needed_atoms=[] 
        for lipidmolecule in molecules_new:
            sys.stdout.flush()
            for item in self.scd_tail_atoms_of[lipidmolecule]:
                list_of_needed_atoms+=item
            print(strftime("%H:%M:%S :", localtime()),"Processing {} ...".format(lipidmolecule))
            grofile_output=self.temppath+'/calc_scd_for'+str(lipidmolecule)+'.gro'
            inp_str=str(lipidmolecule).encode()
            # gmx_traj_arglist = [gmx_exec,'traj','-s',self.tprpath, '-f',self.trjpath,'-oxt',grofile_output]
            gmx_traj_arglist = [gmx_exec,'trjconv','-s',self.tprpath, '-f',self.trjpath,\
                                '-o',grofile_output,\
                                '-b', str(self.t_start), '-e', str(self.t_end),\
                                '-dt', str(self.dt),\
                                '-pbc', 'whole',\
                                ]
            out,err=self.exec_gromacs(gmx_traj_arglist,inp_str)      #Creates a gro file containing {timeframe:resid:atoms:xyz}
            with open("gmx_traj.log","w") as logfile:
                logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
            with open(grofile_output,"r") as grofile:
                print(strftime("%H:%M:%S :", localtime()),"...read data output...")
                for line in grofile:
                    if 't=' in line:
                        time=str(float(line[line.index('t=')+2:].strip()))   #to get rid of obsolete decimals
                        print("...at time {}".format(time),end="\r")
                    for atom in list_of_needed_atoms:
                        if str(atom) in line:
                            resid=line[:5].strip()
                            lipidtype=line[5:9]
                            resid2lipid.update({int(resid):lipidtype})
                            coordinates=[float(x) for x in line[20:44].split()]
                            keystring=lipidtype+time+resid+atom
                            getcoords.update({keystring:coordinates})
        with open("scd_distribution.dat","w") as scdfile:
            print_to_file("Time \t Residue \t Scd",file=scdfile)
            print(strftime("%H:%M:%S :", localtime()),"Write to file...")
            endtime=int(float(time))
            for t in range(0,endtime+1,self.dt):                       #the "time" variable should be the last declared time, thus the last read frame!
                # print("at time {} ...".format(t),end="\r") 
                time=''.join([str(t),'.0'])
                print("at time {} ...".format(t),end="\r") 
                sys.stdout.flush()
                for res in range(1,g_number_of_lipids+1):      
                    totalscd=0
                    normtotalcounter=0
                    lipidmolecule=resid2lipid[res]
                    ### Calculate tilt ###
                    if True:              ### Calculate geometrical center
                        tailcoords=[getcoords[''.join([lipidmolecule,time,x])] for x in self.scd_tail_atoms_of[lipidmolecule][0]]+\
                                        [getcoords[''.join([lipidmolecule,time,x])] for x in self.scd_tail_atoms_of[lipidmolecule][1]]          #Saves coordinates of residue [tail1]+[tail2]
                        headcoords=[]
                        def calculate_
                        for atom in tailcoords:



                    ### end tilt ###
                    for tail in self.scd_tail_atoms_of[lipidmolecule]:
                        orderparametertail=0
                        normcounter=0
                        for atomindex in range(len(tail)-1):
                            atm1=tail[atomindex]
                            atm2=tail[atomindex+1]
                            resid=str(res)
                            coordinates_of_atom1=lipidmolecule+time+resid+atm1
                            coordinates_of_atom2=lipidmolecule+time+resid+atm2
                            
                            dx=getcoords[coordinates_of_atom1][0]-getcoords[coordinates_of_atom2][0]
                            dy=getcoords[coordinates_of_atom1][1]-getcoords[coordinates_of_atom2][1]
                            dz=getcoords[coordinates_of_atom1][2]-getcoords[coordinates_of_atom2][2]
     
                            norm2 = dx**2+dy**2+dz**2
                            cos2 = dz**2 / norm2
                            order = 0.5 * (3 * cos2 - 1)
                            orderparametertail += order
                            #print('resi %d, bond Scd: ' % (int(resid)), order)
                            
                            normcounter+=1
                        orderparametertail=orderparametertail/normcounter
                        totalscd=totalscd+orderparametertail
                        #print('   orderparametertail: ', orderparametertail)
                        normtotalcounter+=1
                    totalscd=totalscd/normtotalcounter    
                    #print('   totalscd: ', totalscd)
                    print_to_file("{} \t {} \t {} \t {}".format(time,res,lipidmolecule,totalscd),file=scdfile)
    
                
    ############################################################################################################################
                
        
    def determine_neighbors(self,overwrite=True):
        print("\n____Determining neighbors____\n")
        try:
            os.mkdir(self.datapath+'/neiborfiles')
        except OSError:
            pass
        with open("neighbor_info","w") as outfile:
            outfile.write('Resid \t Time \t Number_of_neighbors \t List_of_Neighbors \n')
            for residue in range(1,g_number_of_lipids+1):
                print(". . . Working on residue: {} . . .".format(residue),end="\r")
                sys.stdout.flush()
                selectionfile=self.create_selectionfile_neighborsearch(residue)
                indexoutput=self.indexpath+'/neighbors_of_residue{}.ndx'.format(residue)
                datafileoutput=self.datapath+'/neiborfiles'+'/neighbors_of_residue{}.dat'.format(residue)
                if os.path.isfile(datafileoutput) and overwrite==False:
                    print("Neighbor file of residue {} already exists. Skipping.".format(residue))
                    pass
                else:
                    cmdlist=[gmx_exec,'select','-s',self.tprpath,'-f',self.trjpath,'-sf',selectionfile,'-on',indexoutput,'-oi',datafileoutput,\
                                '-b',str(self.t_start), '-e', str(self.t_end),\
                                '-dt', str(self.dt),\
                             ]
                    out,err=self.exec_gromacs(cmdlist)
                    with open("gmx_select.log","w") as logfile:
                        logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
                with open(datafileoutput,"r") as datfile:
                    for line in datfile:
                        cols=line.split()
                        time=cols.pop(0)
                        nneibs=cols.pop(0)
                        neibindeces=[int(x) for x in cols]
                        neibresid=[self.index_to_resid[x] for x in neibindeces]
                        residlist=','.join([str(x) for x in neibresid])
                        print_to_file('{} \t {} \t {} \t {}'.format(residue,time,nneibs,residlist), file=outfile)
                    
            
    ############################################################################################################################

    def calculate_energies(self,resindex_all,mdp_raw,overwrite=True,start=1,end=-1):
        neiblist=self.find_all_neighbors()
        if end==-1:
            end=self.number_of_lipids
        print('\n____Rerunning MD for energyfiles, yielding xvgtables with relevant energies.____\nCaution mdp-file must not have energy_grps indicated!\n')
        for i in range(start,end+1):
           print('\n',strftime("%H:%M:%S :", localtime()),'Working on lipid '+str(i)+'...')
           n_neibs=len(neiblist[i][1])
           if n_neibs % g_denominator == 0:
               number_of_groupfragments=(n_neibs//g_denominator)
           else:
               number_of_groupfragments=(n_neibs//g_denominator)+1

           print("Needing {} energy run(s)".format(number_of_groupfragments)) 
           
           for groupfragment in range(number_of_groupfragments):
                sys.stdout.flush()
                g_energy_output=self.energypath+'/xvgtables/energies_residue'+str(i)+'_'+str(groupfragment)+'.xvg'
                if os.path.isfile(g_energy_output) and overwrite==False:
                    print("Xvgtable for lipid {} part {} already exists. Will skip this calculation.".format(i,groupfragment))
                    continue
                    
                groupblockstart=groupfragment*g_denominator
                groupblockend=(groupfragment+1)*g_denominator
                energygroup_indeces=[neiblist[i][0]]+neiblist[i][1][groupblockstart:groupblockend]
                energygroup_strings=' '.join(["resid_"+str(x) for x in energygroup_indeces])
                select_energies_coulomb='\n'.join(["Coul-SR:resid_"+str(neiblist[i][0])+"-resid_"+str(x) for x in neiblist[i][1][groupblockstart:groupblockend]])
                select_energies_LJ='\n'.join(["LJ-SR:resid_"+str(neiblist[i][0])+"-resid_"+str(x) for x in neiblist[i][1][groupblockstart:groupblockend]])
                select_all_relevant_energies=select_energies_coulomb+"\n"+select_energies_LJ
                groupfragment=str(groupfragment) 


                #Create Mdpfile:
                try:
                    os.mkdir(self.energypath+'/mdpfiles')
                except OSError:
                    pass
                mdpfile=self.energypath+'/mdpfiles/energy_mdp_recalc_resid'+str(i)+'_'+groupfragment+'.mdp'
                with open(mdpfile,"w") as mdpfile_rerun, open(mdp_raw,"r") as mdpfile_raw:
                    mdp_raw_content=mdpfile_raw.readlines()
                    energygrpline='energygrps\t\t\t='+energygroup_strings+'\n'
                    mdp_raw_content.append(energygrpline)
                    mdpfile_rerun.write('\n'.join(mdp_raw_content)+'\n')
                
                
                #Create TPRFILE with GROMPP:
                print(strftime("%H:%M:%S :", localtime()),'...Creating .tpr-file...')
                try:
                    os.mkdir(self.energypath+'/tprfiles')
                except OSError:
                    pass
                tprfile_energyrerun=self.energypath+'/tprfiles/mdrerun_resid'+str(i)+'_'+groupfragment+'.tpr'
                mdpoutfile=self.energypath+'/mdpfiles'+'/mdrerun_resid'+str(i)+'_'+groupfragment+'.mdp'
                # grompp_arglist=[gmx_exec,'-nobackup','grompp','-f',mdpfile,'-p',self.toppath,'-c',self.gropath,'-o',tprfile_energyrerun,'-n',resindex_all,'-po',mdpoutfile]
                grompp_arglist=[gmx_exec,'grompp','-f',mdpfile,'-p',self.toppath,'-c',self.gropath,'-o',tprfile_energyrerun,'-n',resindex_all,'-po',mdpoutfile]
                out,err=self.exec_gromacs(grompp_arglist)
                with open("gmx_grompp.log","a") as logfile:
                    logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
                                
                
                #Create ENERGYFILE with mdrun -rerun:
                print(strftime("%H:%M:%S :", localtime()),'...Rerunning trajectory for energy calculation...')
                try:
                    os.mkdir(self.energypath+'/edrfiles')
                except OSError:
                    pass
                try:
                    os.mkdir(self.energypath+'/logfiles')
                except OSError:
                    pass
                energyfile_output=self.energypath+'/edrfiles/energyfile_resid'+str(i)+'_'+groupfragment+'.edr'
                logoutput_file=self.energypath+'/logfiles'+'/mdrerun_resid'+str(i)+'.log'
                trajoutput="traj"+str(i)+'_'+groupfragment+'.trr'
                # mdrun_arglist=[gmx_exec,'-nobackup','mdrun','-s',tprfile_energyrerun,'-rerun',self.trjpath,'-e',energyfile_output,'-o',trajoutput,'-g',logoutput_file,'-nt','8']
                mdrun_arglist=[gmx_exec,'mdrun','-s',tprfile_energyrerun,'-rerun',self.trjpath,'-e',energyfile_output,'-o',trajoutput,'-g',logoutput_file,'-nt','8']
                out,err=self.exec_gromacs(mdrun_arglist)
                with open("gmx_mdrun.log","a") as logfile:
                   logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
                #os.remove(trajoutput)

       

                #Create XVG-TABLE with all relevant energies:
                print(strftime("%H:%M:%S :", localtime()),'...Extracting all relevant energies from .edr file...')
                try:
                    os.mkdir(self.energypath+'/xvgtables')
                except OSError:
                    pass
                g_energy_output=self.energypath+'/xvgtables/energies_residue'+str(i)+'_'+groupfragment+'.xvg'
                g_energy_arglist=[gmx_exec,'energy','-f',energyfile_output,'-s',tprfile_energyrerun,'-o',g_energy_output]
                inp_str=select_all_relevant_energies.encode()
                out,err=self.exec_gromacs(g_energy_arglist,inp_str)
                with open("gmx_energy.log","a") as logfile:
                    logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
    

    def write_energyfile(self):
        print("______________Writing energy file____________\n")
        neiblist=self.find_all_neighbors()
        with open("all_energies","w") as energyoutput:
            energyoutput.write("{: <10}{: <10}{: <10}{: <20}{: <20}{: <20}\n".format("Time","Host","Neighbor","VdW","Coul","Etot"))
            for resid in range(1,g_number_of_lipids+1):
                n_neibs=len(neiblist[resid][1])
                if n_neibs % g_denominator == 0:
                    number_of_groupfragments=(n_neibs//g_denominator)
                else:
                    number_of_groupfragments=(n_neibs//g_denominator)+1
                for part in range(number_of_groupfragments):
                    print("Working on residue {}".format(resid),end="\r")
                    groupblockstart=part*g_denominator
                    groupblockend=(part+1)*g_denominator
                    neighbors_part_are=neiblist[resid][1][groupblockstart:groupblockend]
                    energypath=self.energypath+'/xvgtables/energies_residue'+str(resid)+'_'+str(part)+'.xvg'
                    with open(energypath,"r") as energyfile:
                        res_to_row={}
                        for energyline in energyfile: #folderlayout is: time Coul_resHost_resNeib LJ_resHost_resNeib ...
                            energyline_cols=energyline.split()
                            if '@ s' in energyline:                     #creating a dict to know which column(energies) belong to which residue
                                rownumber=int(energyline_cols[1][1:])+1                 #time is at row 0 !
                                resnumber=energyline_cols[3].split("resid_")[2][:-1]
                                energytype=energyline_cols[3].split("-")[0][1:]
                                res_to_row.update({energytype+resnumber:rownumber})
                            if '@' not in energyline and '#' not in energyline:     #pick correct energies from energyfile and print
                                time=float(energyline_cols[0])
                                for x in neighbors_part_are:
                                     vdw=energyline_cols[res_to_row['LJ'+str(x)]]
                                     coul=energyline_cols[res_to_row['Coul'+str(x)]]
                                     Etot=float(vdw)+float(coul)
                                     print_to_file("{: <10}{: <10}{: <10}{: <20}{: <20}{: <20.5f}".format(time,resid,x,vdw,coul,Etot), file=energyoutput)
       

    ############################################################################################################################
           
           
    def radialdistribution(self):
        print("\n_____Calculating radial distribution function ____\n")
        try:
            os.mkdir(self.datapath+'/rdf')
        except OSError:
            pass
        selectstringP='name P;\nname P;\nname O3;'
        selectstringO3='name O3;\nname P;\nname O3;'
        selectionfileP=self.temppath+'/selrdfP'
        selectionfileO3=self.temppath+'/selrdfO3'
        outputfileP=self.datapath+'/rdf'+'/rdfhostP.xvg'
        outputfileO3=self.datapath+'/rdf'+'/rdfhostO3.xvg'
        print("...preparing selectionfiles...")
        with open(selectionfileP,"w") as sfP,open(selectionfileO3,"w") as sfO3:
            sfP.write(selectstringP)
            sfO3.write(selectstringO3)
        g_rdf_arglistP=[gmx_exec,'-nobackup','rdf','-f',self.trjpath,'-s',self.tprpath,'-sf',selectionfileP,'-o',outputfileP,'-xy']
        print("...first selection...")
        out,err=self.exec_gromacs(g_rdf_arglistP)
        with open("gmx_rdfP.log","w") as logfile:
            logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
        g_rdf_arglistO3=[gmx_exec,'-nobackup','rdf','-f',self.trjpath,'-s',self.tprpath,'-sf',selectionfileO3,'-o',outputfileO3,'-xy']
        print("...second selection...")
        out,err=self.exec_gromacs(g_rdf_arglistO3)
        with open("gmx_rdfO3.log","w") as logfile:
            logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')

    ############################################################################################################################
        
           
           
    def calculate_distance(self):
        print("\n____Calculating distances____\n")
        neiblist=self.find_all_neighbors()
        try:
            os.mkdir(self.datapath+'/distcalc')
        except OSError:
            pass
        for i in range(1,g_number_of_lipids+1):
            sys.stdout.flush()
            print("Working on lipid ",i,'...',end='\r')
            host=str(neiblist[i][0])
            neibors=[str(x) for x in neiblist[i][1]]
            selectstring='resid '+host+' and name P O3;\n'
            for x in neibors:
                selectstring+='resid '+x+' and name P O3;\n'
            selectionfile=self.temppath+'/seldist'
            outputfile=self.datapath+'/distcalc'+'/dist_to_hostresid'+str(i)+'.xvg'
            with open(selectionfile,"w") as sf:
                sf.write(selectstring)    
            g_pairdist_arglist=[gmx_exec,'-nobackup','pairdist','-f',self.trjpath,'-s',self.tprpath,'-sf',selectionfile,'-o',outputfile]
            out,err=self.exec_gromacs(g_pairdist_arglist)
            with open("gmx_pairdist.log","w") as logfile:
                logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
        with open("all_distances.dat","w") as all_distances:
            # print("Time \t Host \t Neib \t distance/nm",file=all_distances)
            print_to_file("Time \t Host \t Neib \t distance/nm",file=all_distances)
            for resid in range(1,g_number_of_lipids+1):
                sys.stdout.flush()
                print("Working on residue {}".format(resid),end="\r")
                distancefile=self.datapath+'/distcalc/dist_to_hostresid'+str(resid)+'.xvg'
                with open(distancefile,"r") as dfile:
                    res_to_row={}
                    for distanceline in dfile: #folderlayout is: time distance_resHost_resNeib ...
                        distanceline_cols=distanceline.split()
                        if '@ s' in distanceline:                     #creating a dict to know which column(energies) belong to which residue
                            rownumber=int(distanceline_cols[1][1:])+1                 #time is at row 0 !
                            resnumber=distanceline_cols[4]
                            res_to_row.update({resnumber:rownumber})
                        if '@' not in distanceline and '#' not in distanceline:     #pick correct energies from energyfile and print
                            time_distanceline=float(distanceline_cols[0])
                            neighbors_are=neiblist[resid][1]
                            for x in neighbors_are:
                                 distance=distanceline_cols[res_to_row[str(x)]]
                                 print_to_file("{} \t {} \t {} \t {}".format(time_distanceline,resid,x,distance),file=all_distances)

    def create_scdmap(self,scd_distribution,overwrite=False):
        grofile_output=self.temppath+'/calc_scd_for'+str(lipidmolecule)+'.gro'
        if os.path.isfile(datafileoutput) and overwrite==False:
            print("Writing trajectory as .gro")
            inp_str=str(lipidmolecule).encode()
            gmx_traj_arglist = [gmx_exec,'trjconv','-s',self.tprpath, '-f',self.trjpath,\
                                '-o',grofile_output,\
                                '-b', str(self.t_start), '-e', str(self.t_end),\
                                '-dt', str(self.dt),\
                                '-pbc', 'whole',\
                                ]
            out,err=self.exec_gromacs(gmx_traj_arglist,inp_str)      #Creates a gro file containing {timeframe:resid:atoms:xyz}
            with open("gmx_traj.log","w") as logfile:
                logfile.write(err.decode()); logfile.write(150*'_'); logfile.write(out.decode()); logfile.write(150*'_')
            with open(grofile_output,"r") as grofile:
                print(strftime("%H:%M:%S :", localtime()),"...read data output...")
                for line in grofile:
                    if 't=' in line:
                        time=str(float(line[line.index('t=')+2:].strip()))   #to get rid of obsolete decimals
                        print("...at time {}".format(time),end="\r")
                    for atom in list_of_needed_atoms:
                        if str(atom) in line:
                            resid=line[:5].strip()
                            lipidtype=line[5:9]
                            resid2lipid.update({int(resid):lipidtype})
                            coordinates=[float(x) for x in line[20:44].split()]
                            keystring=lipidtype+time+resid+atom
            




    ############################################################################################################################
    ############################################################################################################################
    ############################################################################################################################

    ''' __________________________________________ Create Inputfiles ____________________________________________________ ''' 


    def create_Eofr_input(self,energyfile,distancefile):
        time_pair_to_E={}
        time_pair_to_r={}
        with open(energyfile,"r") as efile, open(distancefile,"r") as dfile:
            firstline_efile=efile.readline()
            firstline_dfile=dfile.readline()
            for line in efile:
                cols=line.split()
                time=cols[0]
                respair=cols[1]+'-'+cols[2]
                Etot=cols[5]
                keystring=time+'_'+respair
                time_pair_to_E.update({keystring:Etot})
            for line in dfile:
                cols=line.split()
                time=cols[0]
                respair=cols[1]+'-'+cols[2]
                distance=cols[3]
                keystring=time+'_'+respair
                time_pair_to_r.update({keystring:distance})
        with open("Eofr_dat","w") as outfile:
            print_to_file("{: <10} {: <10} {: <10} {: < 10} {: <20}\n".format("Time","Host","Neib","Distance","Etot"),file=outfile)
            endtime=int(float(time))
            neiblist=self.find_all_neighbors()
            for i in range(1,g_number_of_lipids+1):
                for t in range(0,endtime+1,self.dt):
                    time=str(t)+'.0'
                    neighbors_are=neiblist[i][1]
                    for neib in neighbors_are:
                        respair=str(i)+'-'+str(neib)
                        Etot=time_pair_to_E[time+'_'+respair]
                        dist=time_pair_to_r[time+'_'+respair]
                        print_to_file("{: <10} {: <10} {: <10} {: < 10} {: <20.5f}".format(time,i,neib,dist,Etot),file=outfile)

    def create_EofScd_input(self,energyfile,scdfile,neighborfile):
        time_pair_to_E={}
        time_resid_to_scd={}
        neighbors_of_host={}
        hosts_without_neib=[]
        with open(energyfile,"r") as efile, open(scdfile,"r") as sfile, open(neighborfile,"r") as nfile:
            firstline_efile=efile.readline()
            firstline_sfile=sfile.readline()
            firstline_nfile=nfile.readline()
            for line in efile:
                cols=line.split()
                time=cols[0]
                respair=cols[1]+'-'+cols[2]
                Etot=cols[5]
                VDW=cols[4]
                COUL=cols[3]
                keystringTOT="TOT"+time+'_'+respair
                keystringVDW="VDW"+time+'_'+respair
                keystringCOUL="COUL"+time+'_'+respair
                time_pair_to_E.update({keystringTOT:Etot})
                time_pair_to_E.update({keystringVDW:VDW})
                time_pair_to_E.update({keystringCOUL:COUL})
            for line in sfile:
                cols=line.split()
                time=cols[0]
                res=cols[1]
                scd=cols[3]
                keystring=time+'_'+res
                time_resid_to_scd.update({keystring:scd})
            for line in nfile:
                cols=line.split()
                time=str(float(cols[1]))
                host=cols[0]
                if int(cols[2])==0:
                    print(host,"has no neighbors at time",time)
                    hosts_without_neib+=[time+'_'+host]
                    continue
                neighbors=cols[3]
                keystring=time+'_'+host
                neighbors_of_host.update({keystring:neighbors})
        with open("Eofscd_dppc_dppc.dat","w") as outfile_dppc_dppc, open("Eofscd_dppc_chol.dat","w") as outfile_dppc_chol,open("Eofscd_chol_chol.dat","w") as outfile_chol_chol, open("Eofscd_dupc_chol.dat","w") as outfile_dupc_chol:
            if 'DPPC' in self.molecules:
                print_to_file("{: <10}{: <10}{: <20}{: <10}{: <20}{: <20}{: <20}{: <20}{: <20}{: <20}".format("Time","Host","Host_Scd","Neib","Neib_Scd","DeltaScd","AvgScd","Etot","Evdw","Ecoul"),file=outfile_dppc_dppc)
            if 'CHOL' in self.molecules and 'DPPC' in self.molecules: 
                print_to_file("{: <10}{: <10}{: <20}{: <10}{: <20}{: <20}{: <20}{: <20}{: <20}{: <20}".format("Time","Host","Host_Scd","Neib","Neib_Scd","DeltaScd","AvgScd","Etot","Evdw","Ecoul"),file=outfile_dppc_chol)
            if 'CHOL' in self.molecules and 'DUPC' in self.molecules: 
                print_to_file("{: <10}{: <10}{: <20}{: <10}{: <20}{: <20}{: <20}{: <20}{: <20}{: <20}".format("Time","Host","Host_Scd","Neib","Neib_Scd","DeltaScd","AvgScd","Etot","Evdw","Ecoul"),file=outfile_dupc_chol)
            if 'CHOL' in self.molecules: 
                print_to_file("{: <10}{: <10}{: <20}{: <10}{: <20}{: <20}{: <20}{: <20}{: <20}{: <20}".format("Time","Host","Host_Scd","Neib","Neib_Scd","DeltaScd","AvgScd","Etot","Evdw","Ecoul"),file=outfile_chol_chol)
            endtime=int(float(time))
            for i in range(1,g_number_of_lipids+1):
                print("Working on residue {} ".format(i),end="\r")
                type_host=self.resid_to_lipid[i]
                for t in range(0,endtime+1,self.dt):
                    time=str(t)+'.0'
                    if time+'_'+str(i) in hosts_without_neib:
                        continue
                    neighbors_are=neighbors_of_host[time+'_'+str(i)].split(',')
                    for neib in neighbors_are:
                        type_neib=self.resid_to_lipid[int(neib)]
                        type_pair=type_host+'_'+type_neib
                        scd_host=float(time_resid_to_scd[time+'_'+str(i)])
                        scd_neib=float(time_resid_to_scd[time+'_'+str(neib)])
                        delta_scd=abs(scd_host-scd_neib)
                        avg_scd=(scd_host+scd_neib)/2
                        respair=str(i)+'-'+str(neib)
                        keystrTOT="TOT"+time+'_'+respair
                        keystrVDW="VDW"+time+'_'+respair
                        keystrCOUL="COUL"+time+'_'+respair
                        Etot=time_pair_to_E[keystrTOT]
                        VDW=time_pair_to_E[keystrVDW]
                        COUL=time_pair_to_E[keystrCOUL]
                        if type_pair=='DPPC_DPPC':
                            print_to_file("{: <10}{: <10}{: <20.5f}{: <10}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}".format(time,i,scd_host,neib,scd_neib,delta_scd,avg_scd,float(Etot),float(VDW),float(COUL)),file=outfile_dppc_dppc)
                        if type_pair=='DPPC_CHL1' or type_pair=='CHL1_DPPC':
                            print_to_file("{: <10}{: <10}{: <20.5f}{: <10}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}".format(time,i,scd_host,neib,scd_neib,delta_scd,avg_scd,float(Etot),float(VDW),float(COUL)),file=outfile_dppc_chol)
                        if type_pair=='DUPC_CHL1':
                            print_to_file("{: <10}{: <10}{: <20.5f}{: <10}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}".format(time,i,scd_host,neib,scd_neib,delta_scd,avg_scd,float(Etot),float(VDW),float(COUL)),file=outfile_dupc_chol)
                        if type_pair=='CHL1_CHL1':
                            print_to_file("{: <10}{: <10}{: <20.5f}{: <10}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}{: <20.5f}".format(time,i,scd_host,neib,scd_neib,delta_scd,avg_scd,float(Etot),float(VDW),float(COUL)),file=outfile_chol_chol)

    def create_NofScd_input(self,scdfile,neighborfile):
        time_resid_to_scd={}
        neighbors_of_host={}
        hosts_without_neib=[]
        with open(scdfile,"r") as sfile, open(neighborfile,"r") as nfile:
            firstline_sfile=sfile.readline()
            firstline_nfile=nfile.readline()
            for line in sfile:
                cols=line.split()
                time=cols[0]
                res=cols[1]
                scd=cols[3]
                keystring=time+'_'+res
                time_resid_to_scd.update({keystring:scd})
            for line in nfile:
                cols=line.split()
                time=str(float(cols[1]))
                host=cols[0]
                if int(cols[2])==0:
                    print(host,"has no neighbors at time",time)
                    hosts_without_neib+=[time+'_'+host]
                    continue
                neighbors=cols[3]
                keystring=time+'_'+host
                neighbors_of_host.update({keystring:neighbors})
        with open("Nofscd_dppc.dat","w") as outfile_dppc, open("Nofscd_chol.dat","w") as outfile_chol,open("Nofscd_dupc.dat","w") as outfile_dupc:
            print_to_file("{: <10} {: <10} {: <20} {: <20} {: <10} {: <10} {: <10}".format("Time","Host","Host_Scd","N Neighbor","N Chol","N DPPC","N DUPC"),file=outfile_dppc)
            print_to_file("{: <10} {: <10} {: <20} {: <20} {: <10} {: <10} {: <10}".format("Time","Host","Host_Scd","N Neighbor","N Chol","N DPPC","N DUPC"),file=outfile_chol)
            print_to_file("{: <10} {: <10} {: <20} {: <20} {: <10} {: <10} {: <10}".format("Time","Host","Host_Scd","N Neighbor","N Chol","N DPPC","N DUPC"),file=outfile_dupc)
            endtime=int(float(time))
            for i in range(1,g_number_of_lipids+1):
                restype=self.resid_to_lipid[i]
                print("Working on residue {} ".format(i),end="\r")
                for t in range(0,endtime+1,self.dt):
                    time=str(t)+'.0'
                    if time+'_'+str(i) in hosts_without_neib:
                        continue
                    n_neibs=len(neighbors_of_host[time+'_'+str(i)].split(','))
                    neibindexlist=neighbors_of_host[time+'_'+str(i)].split(',')
                    neibtypelist=[self.resid_to_lipid[int(resid)] for resid in neibindexlist]
                    nchol=neibtypelist.count('CHL1')
                    ndppc=neibtypelist.count('DPPC')
                    ndupc=neibtypelist.count('DUPC')
                    scd_host=float(time_resid_to_scd[time+'_'+str(i)])
                    if restype=='DPPC':
                        print_to_file("{: <10}{: <10}{: <20.5f}{: <20.5f}{: <10}{: <10}{: <10}".format(time,i,scd_host,float(n_neibs),nchol,ndppc,ndupc),file=outfile_dppc)
                    elif restype=='CHL1':
                        print_to_file("{: <10}{: <10}{: <20.5f}{: <20.5f}{: <10}{: <10}{: <10}".format(time,i,scd_host,float(n_neibs),nchol,ndppc,ndupc),file=outfile_chol)
                    elif restype=='DUPC':
                        print_to_file("{: <10}{: <10}{: <20.5f}{: <20.5f}{: <10}{: <10}{: <10}".format(time,i,scd_host,float(n_neibs),nchol,ndppc,ndupc),file=outfile_dupc)

    
    def create_scd_histogram(self,scdfile):
        grofile_output=self.temppath+'/calc_scd_for'+str(lipidmolecule)+'.gro'

        time_resid_to_scd={}
        with open(scdfile,"r") as sfile:
            firstline_sfile=sfile.readline()
            for line in sfile:
                cols=line.split()
                time=cols[0]
                res=cols[1]
                scd=cols[3]
                keystring=time+'_'+res
                time_resid_to_scd.update({keystring:scd})
        with open("scd_distribution_dppc.dat","w") as outfile_dppc, open("scd_distribution_dupc.dat","w") as outfile_dupc, open("scd_distribution_chol.dat","w") as outfile_chol:
            print_to_file("{: <10} {: <10} {: <20}".format("Time","Lipid","Lipid_Scd"),file=outfile_dppc)
            print_to_file("{: <10} {: <10} {: <20}".format("Time","Lipid","Lipid_Scd"),file=outfile_chol)
            print_to_file("{: <10} {: <10} {: <20}".format("Time","Lipid","Lipid_Scd"),file=outfile_dupc)
            endtime=int(float(time))
            for i in range(1,g_number_of_lipids+1):
                restype=self.resid_to_lipid[i]
                print("Working on residue {} ".format(i),end="\r")
                for t in range(0,endtime+1,self.dt):
                    time=str(t)+'.0'
                    scd_host=float(time_resid_to_scd[time+'_'+str(i)])
                    if restype=='DPPC':
                        print_to_file("{: <10}{: <10}{: <20.5f}".format(time,i,scd_host),file=outfile_dppc)
                    elif restype=='CHL1':
                        print_to_file("{: <10}{: <10}{: <20.5f}".format(time,i,scd_host),file=outfile_chol)
                    elif restype=='DUPC':
                        print_to_file("{: <10}{: <10}{: <20.5f}".format(time,i,scd_host),file=outfile_dupc)

    def neighbor_fraction(self,neighborfile):
        lipid_pairs={}
        print(self.molecules)
        mol=self.molecules.copy()
        mol.remove('CHOL')
        for lipid in mol:
            for index in range(len(mol)):
                lipid_pairs.update({str(lipid)+'_'+str(mol[index]):{}})
        with open(neighborfile,"r") as neibfile:
            header=neibfile.readline()
            for line in neibfile:
                cols=line.split()
                if int(cols[2])==0:
                    continue
                for resid in cols[3].split(','):
                    host=self.resid_to_lipid[int(cols[0])]
                    neib=self.resid_to_lipid[int(resid)]
                    pair1=host+'_'+neib         
                    #pair2=neib+host         
                    time=cols[1]
                    try:
                        lipid_pairs[pair1][time].append(pair1)
                    except:
                        lipid_pairs[pair1].update({time:[]})
                        lipid_pairs[pair1][time].append(pair1)
        with open("dppc_pairs.dat","w") as pdppc, open("chol_pairs.dat","w") as pchol, open("dppc_chol_pairs.dat","w") as pdppchol:
            #for pair in sorted(lipid_pairs.keys()):
            for time in sorted(lipid_pairs['DPPC_CHL1'].keys()):
                print(time,len(lipid_pairs['DPPC_CHL1'][time]),file=pdppchol)
            for time in sorted(lipid_pairs['CHL1_CHL1'].keys()):
                print(time,0.5*len(lipid_pairs['CHL1_CHL1'][time]),file=pchol)
            for time in sorted(lipid_pairs['DPPC_DPPC'].keys()):
                print(time,0.5*len(lipid_pairs['DPPC_DPPC'][time]),file=pdppc)

    ############################################################################################################################
    ############################################################################################################################
    ############################################################################################################################




##
#''' Execute '''
#starttime=datetime.now()
#print("Job started at:",strftime("%H:%M:%S", localtime()))
##
#obj = AnalyseLipidSystem("inputfile")
#
#obj.determine_neighbors()
#obj.create_indexfile()
#obj.calculate_scds()
#obj.calculate_energies("resindex_all","energy_recalculation.mdp")
#obj.write_energyfile()
#obj.create_EofScd_input('all_energies', 'scd_distribution.dat')
#obj.calculate_distance()
#obj.radialdistribution()



